# Blackboard Parser Language v1.0

> (Start);

# Integers
(Start): '0' => (Zero): '0'..'9' => (Int);
(Start): '1'..'9' => (Int): '0'..'9' => [Int];
(Zero) => [Int];

# Floats
(Start): '.' => (Decimal);
(Int): '.' => (Decimal): '0'..'9' => (Float-Dec): '0'..'9' => (Float-Dec) => [Float];
(Int): 'eE' => (Float-Exp-Start): '-' => (Float-Exp-Neg): '0'..'9' => (Float-Exp);
(Float-Dec): 'eE' => (Float-Exp-Start): '0'..'9' => (Float-Exp): '0'..'9' => (Float-Exp) => [Float];

# Hexadecimals
(Zero): 'x' => (Hex-Start): '0'..'9', 'a'..'f', 'A'..'F' => (Hex): '0'..'9', 'a'..'f', 'A'..'F' => [Hex];

# Identifiers
(Start): 'a'..'z', 'A'..'Z', '_$' => (Identifier): '0'..'9', 'a'..'z', 'A'..'Z', '_' => [Identifier];
(Identifier): '.' => (Scoping): 'a'..'z', 'A'..'Z', '_' => (Identifier);

# Symbols
(Start): '&' => [And]: '&' => [Logical-And];
(Start): '|' => [Or]: '|' => [Logical-Or];
(Start): '+' => [Pos];
(Start): '-' => [Neg]: '>' => [Trigger];
(Start): '/' => [Div];
(Start): '*' => [Mul]: '*' => [Power];
(Start): '%' => [Mod]: '%' => [Remainder];
(Start): '^' => [Xor]: '^' => [Logical-Xor];
(Start): '~' => [Invert];
(Start): '?' => [Test];
(Start): ':' => [Else]: '=' => [Define];
(Start): ';' => [End];
(Start): ',' => [Comma];

(Start): '(' => [Par-Open];
(Start): ')' => [Par-Close];
(Start): '[' => [Sqr-Open];
(Start): ']' => [Sqr-Close];
(Start): '{' => [Curl-Open];
(Start): '}' => [curl-Close];

(Start): '=' => [Assign]:  '=' => [Equal];
(Start): '>' => [Greater]: '=' => [Greater-Equal];
(Start): '<' => [Less]:    '=' => [Less-Equal];
(Start): '!' => [Not]:     '=' => [Not-Equal];
(Greater): '>' => [Shift-Right];
(Less):    '<' => [Shift-Left];

# Comments
(Div): '/' => (Comment-Single): !'\n' => (Comment-Single) => ^[Comment];
(Div): '*' => (Comment-Multiple): '*' => (Comment-Multiple-End): '/' => (Comment-End) => ^[Comment];
(Comment-Multiple): * => (Comment-Multiple);
(Comment-Multiple-End): * => (Comment-Multiple);

# Whitespace
(Start): ' \t\n' => (Whitespace): ' \t\n' => ^[Whitespace];

# Reserved Identifiers
[Identifier] = 'in' => [In];
[Identifier] = 'const' => [Const];
[Identifier] = 'bool', 'int', 'float', 'trigger' => [Type];
[Identifier] = 'true', 'false' => [Bool];
[Identifier] = 'and', 'as', 'byte', 'catch', 'case', 'char', 'class', 'complex', 'def', 'default', 'do', 'dynamic',
               'else', 'enum', 'finally', 'for', 'foreach', 'func', 'get', 'global', 'if', 'interface', 'import', 'is',
               'list', 'local', 'map', 'namespace', 'not', 'null', 'on', 'operator', 'or', 'out', 'override', 'select',
               'set', 'static', 'string', 'switch', 'then', 'try', 'type', 'typedef', 'typeof', 'uint', 'until',
               'var', 'void', 'when', 'while', 'yield', 'xor' => [Reserved];

#==========================================================
# Grammar Rules

> <Code> := _
    | <Statement> [End] {Clean} <Code>;

<Statement> := _
    | [In] [Type] [Identifier] {NewInput}
    | [In] [Type] [Identifier] {NewInput} {StartAssign} [Assign] <Complex> {EndAssign}
    | [Identifier] {LookupInput} {StartAssign} [Assign] <Complex> {EndAssign}
    | [Identifier] [Define] {StartDefine} <Complex> {EndDefine}
    | [Type] [Identifier] [Define] {StartDefine} <Complex> {EndDefineWithType}
    | [Trigger] [Identifier] {PullTrigger};

<Complex> := <Expression>
    | <Complex> [Test] <Complex> [Else] <Complex> {Trinary};

<Expression> := <Term>
    | <Expression> [Pos] <Term> {Sum}
    | <Expression> [Neg] <Term> {Subtract}
    | <Expression> [Or] <Term> {Or};

<Term> := <Factor>
    | <Term> [Mul] <Factor> {Multiply}
    | <Term> [Div] <Factor> {Divide}
    | <Term> [Mod] <Factor> {Modulo}
    | <Term> [Xor] <Factor> {Xor};

<Factor> := <Value>
    | [Par-Open] <Complex> [Par-Close]
    | [Neg] <Factor> {Negate}
    | [Not] <Factor> {Not}
    | [Pos] <Factor>
    | [Invert] <Factor> {Invert}
    | [Identifier] {StartCall} [Par-Open] <Args> [Par-Close] {EndCall};
    
<Args> := _
    | <Complex> <Args-Tail>;

<Args-Tail> := _
    | [Comma] <Complex> <Args-Tail>;

<Value> := [Identifier] {PushId}
    | [Bool] {PushBool}
    | [Int] {PushInt}
    | [Float] {PushFloat};
