# Blackboard Parser Language v1.0

> (Start);

# Integers
(Start): '0' => (Zero): '0'..'9' => (Int);
(Start): '1'..'9' => (Int): '0'..'9' => [Int];
(Zero) => [Int];

# Doubles
(Start): '.' => (Decimal);
(Int): '.' => (Decimal): '0'..'9' => (DoubleDec): '0'..'9' => (DoubleDec) => [Double];
(Int): 'eE' => (DoubleExpStart): '-' => (DoubleExpNeg): '0'..'9' => (DoubleExp);
(DoubleDec): 'eE' => (DoubleExpStart): '0'..'9' => (DoubleExp): '0'..'9' => (DoubleExp) => [Double];

# Hexadecimals
(Zero): 'x' => (HexStart): '0'..'9', 'a'..'f', 'A'..'F' => (Hex): '0'..'9', 'a'..'f', 'A'..'F' => [Hex];

# Identifiers
(Start): 'a'..'z', 'A'..'Z', '_$' => (Identifier): '0'..'9', 'a'..'z', 'A'..'Z', '_' => [Identifier];

# Strings
(Start): '"' => (StringBody): '"' => [String];
(StringBody): '\\' => (Escaped);
(Escaped): 'x' => (Ascii_0): '0'..'9', 'a'..'f', 'A'..'F' =>
                  (Ascii_1): '0'..'9', 'a'..'f', 'A'..'F' => (StringBody);
(Escaped): 'u' => (Unicode_0): '0'..'9', 'a'..'f', 'A'..'F' =>
                  (Unicode_1): '0'..'9', 'a'..'f', 'A'..'F' =>
                  (Unicode_2): '0'..'9', 'a'..'f', 'A'..'F' =>
                  (Unicode_3): '0'..'9', 'a'..'f', 'A'..'F' => (StringBody);
(Escaped): * => (StringBody);

# Symbols
(Start): '&' => [And]: '&' => [LogicalAnd];
(Start): '|' => [Or]: '|' => [LogicalOr];
(Start): '+' => [Pos];
(Start): '-' => [Neg]: '>' => [Trigger];
(Start): '/' => [Div];
(Start): '*' => [Mul]: '*' => [Power];
(Start): '%' => [Mod]: '%' => [Remainder];
(Start): '^' => [Xor]: '^' => [LogicalXor];
(Start): '~' => [Invert];
(Start): '?' => [Test];
(Start): ':' => [Else]: '=' => [Define];
(Start): ';' => [End];
(Start): ',' => [Comma];
(Start): '.' => [Dot];

(Start): '(' => [ParOpen];
(Start): ')' => [ParClose];
(Start): '[' => [SqrOpen];
(Start): ']' => [SqrClose];
(Start): '{' => [CurlOpen];
(Start): '}' => [CurlClose];

(Start): '=' => [Assign]:  '=' => [Equal];
(Start): '>' => [Greater]: '=' => [GreaterEqual];
(Start): '<' => [Less]:    '=' => [LessEqual];
(Start): '!' => [Not]:     '=' => [NotEqual];
(Greater): '>' => [ShiftRight];
(Less):    '<' => [ShiftLeft];

# Comments
(Div): '/' => (CommentSingle): !'\n' => (CommentSingle) => ^[Comment];
(Div): '*' => (CommentMultiple): '*' => (CommentMultipleEnd): '/' => (CommentEnd) => ^[Comment];
(CommentMultiple): * => (CommentMultiple);
(CommentMultipleEnd): * => (CommentMultiple);

# Whitespace
(Start): ' \t\n' => (Whitespace): ' \t\n' => ^[Whitespace];

# Specific Keywords
[Identifier] = 'true', 'false' => [Bool];
[Identifier] = 'namespace' => [Namespace];

[Identifier] = 'in'      => [DeclareIn];
[Identifier] = 'get'     => [DeclareGet];
[Identifier] = 'const'   => [DeclareConst];
[Identifier] = 'counter' => [DeclareCounter];
[Identifier] = 'latch'   => [DeclareLatch];
[Identifier] = 'toggle'  => [DeclareToggle];

[Identifier] = 'bool'    => [TypeBool];
[Identifier] = 'int'     => [TypeInt];
[Identifier] = 'double'  => [TypeDouble];
[Identifier] = 'string'  => [TypeString];
[Identifier] = 'trigger' => [TypeTrigger];

# Reserved Identifiers (Keeping options open for future versions)
[Identifier] = 'byte', 'char', 'enum', 'float', 'int8', 'int16', 'int32', 'int64',
               'list', 'long', 'map', 'set', 'short', 'struct', 'type', 'uint',
               'uint8', 'uint16', 'uint32', 'uint64', 'ulong', 'ushort', 'var' => [ReservedTypes];

[Identifier] = 'internal', 'global', 'local',
               'private', 'protected', 'public', 'static' => [ReservedScoping];

[Identifier] = 'abstract', 'class', 'def', 'define', 'func', 'interface', 'operator',
               'override', 'typedef', 'void', 'virtual' => [ReservedDefinitions];

[Identifier] = 'as', 'break', 'catch', 'case', 'continue', 'default', 'else',
               'finally', 'go', 'if', 'import', 'intersect', 'is', 'out', 'return', 'select',
               'switch', 'then', 'try', 'typeof', 'union', 'using', 'when', 'yield' => [ReservedConstructs];

[Identifier] = 'complex', 'do', 'dynamic', 'for', 'foreach', 'goto',
               'label', 'null', 'readonly', 'sealed', 'until', 'while' => [ReservedUnsupported];

#==========================================================
# Grammar Rules

> <Code> := _
    | {clear} [Namespace] [Identifier] {pushNamespace} [CurlOpen] <Code> [CurlClose] {popNamespace} <Code>
    | {clear} <Statement> [End] <Code>;

<Statement> := _
    | <NewTypedInput>
#    | <NewVarInput>
#    | <AssignExisting>
#    | <DefineTypedRule>
#    | <DefineVarRule>
#    | <PullTrigger>
    ;

#----------------------------------------------------------

<NewTypedInput> := [DeclareIn] <AnyBaseType> {startNewTypedInput} <NewTypedInputPart> <NewTypedInputTail>;

<NewTypedInputTail> := _
    | [Comma] <NewTypedInputPart> <NewTypedInputTail>;

<NewTypedInputPart> := [Identifier] {pushId} {newTypeInputNoAssign}
    | [Identifier] {pushId} [Assign] <Conditional> {newTypeInputWithAssign};

#----------------------------------------------------------

###<NewVarInput> := [DeclareIn] <NewVarInputPart> <NewVarInputTail> [End];
###
###<NewVarInputTail> := _
###    | [Comma] <NewVarInputPart> <NewVarInputTail>;
###
###<NewVarInputPart> := [Identifier] [Assign] <Conditional> {newVarInputWithAssign};

#----------------------------------------------------------

###<AssignExisting> := <Id> <AssignExistingMore> [Assign] <Conditional> {assignExisting};
###
###<AssignExistingMore> := _
###    | [Assign] <Id> <AssignExistingMore>;
###
###<DefineTypedRule> := {startDefine} [Type] {setType} <Id> [Define] <Conditional> {typeDefine};
###
###<DefineVarRule> := {startDefine} <Id> [Define] <Conditional> {varDefine};
###
###<PullTrigger> := [Trigger] <Id> {pullTrigger}
###    | <Conditional> [Trigger] <Id> {conditionalPullTrigger};
    
#==========================================================

<Conditional> := <LogicalOr>
    | <Conditional> [Test] <Conditional> [Else] <Conditional> {trinary};

<LogicalOr> := <LogicalXor>
    | <LogicalOr> [LogicalOr] <LogicalXor> {logicalOr};
    
<LogicalXor> := <LogicalAnd>
    | <LogicalXor> [LogicalXor] <LogicalAnd> {logicalXor};

<LogicalAnd> := <Equality>
    | <LogicalAnd> [LogicalAnd] <Equality> {logicalAnd};

<Equality> := <Relational>
    | <Equality> [Equal]    <Relational> {equal}
    | <Equality> [NotEqual] <Relational> {notEqual};

<Relational> := <BitwiseOr>
    | <Relational> [Greater]      <BitwiseOr> {greater}
    | <Relational> [Less]         <BitwiseOr> {less}
    | <Relational> [GreaterEqual] <BitwiseOr> {greaterEqual}
    | <Relational> [LessEqual]    <BitwiseOr> {lessEqual};

<BitwiseOr> := <BitwiseXor>
    | <BitwiseOr> [Or] <BitwiseXor> {or};
    
<BitwiseXor> := <BitwiseAnd>
    | <BitwiseXor> [Xor] <BitwiseAnd> {xor};

<BitwiseAnd> := <BitwiseShift>
    | <BitwiseAnd> [And] <BitwiseShift> {and};

<BitwiseShift> := <Additive>
    | <BitwiseShift> [ShiftRight] <Additive> {shiftRight}
    | <BitwiseShift> [ShiftLeft]  <Additive> {shiftLeft};

<Additive> := <Multiplicative>
    | <Additive> [Pos] <Multiplicative> {sum}
    | <Additive> [Neg] <Multiplicative> {subtract};

<Multiplicative> := <Unary>
    | <Multiplicative> [Mul]       <Exponent> {multiply}
    | <Multiplicative> [Div]       <Exponent> {divide}
    | <Multiplicative> [Mod]       <Exponent> {modulo}
    | <Multiplicative> [Remainder] <Exponent> {remainder};

<Exponent> := <Unary>
    | <Exponent> [Power] <Unary> {power};

<Unary> := <Expression>
    | [Neg]    <Expression> {negate}
    | [Not]    <Expression> {not}
    | [Pos]    <Expression>
    | [Invert] <Expression> {invert}
    | [ParOpen] <AnyBaseType> [ParClose] <Expression> {cast};

<Expression> := <Value>
    | [ParOpen] <Conditional> [ParClose]
    | <Expression> [Dot] [Identifier] {memberAccess}
    | <Expression> [ParOpen] {startCall} <Args> [ParClose] {endCall};

<Args> := _
    | <Conditional> <ArgsTail>;

<ArgsTail> := _
    | [Comma] <Conditional> <ArgsTail>;

<Value> := [Identifier] {pushId}
    | [Bool]   {pushBool}
    | [Int]    {pushInt}
    | [Hex]    {pushHex}
    | [Double] {pushDouble}
    | [String] {pushString};

<AnyBaseType> := [TypeBool] {pushType}
    | [TypeInt]     {pushType}
    | [TypeDouble]  {pushType}
    | [TypeString]  {pushType}
    | [TypeTrigger] {pushType};
