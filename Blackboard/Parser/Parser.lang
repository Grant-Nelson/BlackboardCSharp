# Blackboard Parser Language v1.0

> (Start);

# Integers
(Start): '0' => (Zero): '0'..'9' => (Int);
(Start): '1'..'9' => (Int): '0'..'9' => [Int];
(Zero) => [Int];

# Doubles
(Start): '.' => (Decimal);
(Int): '.' => (Decimal): '0'..'9' => (Double-Dec): '0'..'9' => (Double-Dec) => [Double];
(Int): 'eE' => (Double-Exp-Start): '-' => (Double-Exp-Neg): '0'..'9' => (Double-Exp);
(Double-Dec): 'eE' => (Double-Exp-Start): '0'..'9' => (Double-Exp): '0'..'9' => (Double-Exp) => [Double];

# Hexadecimals
(Zero): 'x' => (Hex-Start): '0'..'9', 'a'..'f', 'A'..'F' => (Hex): '0'..'9', 'a'..'f', 'A'..'F' => [Hex];

# Identifiers
(Start): 'a'..'z', 'A'..'Z', '_$' => (Identifier): '0'..'9', 'a'..'z', 'A'..'Z', '_' => [Identifier];

# Strings
(Start): '"' => (String-Body): '"' => [String];
(String-Body): '\\' => (Escaped);
(Escaped): 'x' => (Ascii-0): '0'..'9', 'a'..'f', 'A'..'F' =>
                  (Ascii-1): '0'..'9', 'a'..'f', 'A'..'F' => (String-Body);
(Escaped): 'u' => (Unicode-0): '0'..'9', 'a'..'f', 'A'..'F' =>
                  (Unicode-1): '0'..'9', 'a'..'f', 'A'..'F' =>
                  (Unicode-2): '0'..'9', 'a'..'f', 'A'..'F' =>
                  (Unicode-3): '0'..'9', 'a'..'f', 'A'..'F' => (String-Body);
(Escaped): * => (String-Body);

# Symbols
(Start): '&' => [And]: '&' => [Logical-And];
(Start): '|' => [Or]: '|' => [Logical-Or];
(Start): '+' => [Pos];
(Start): '-' => [Neg]: '>' => [Trigger];
(Start): '/' => [Div];
(Start): '*' => [Mul]: '*' => [Power];
(Start): '%' => [Mod]: '%' => [Remainder];
(Start): '^' => [Xor]: '^' => [Logical-Xor];
(Start): '~' => [Invert];
(Start): '?' => [Test];
(Start): ':' => [Else]: '=' => [Define];
(Start): ';' => [End];
(Start): ',' => [Comma];
(Start): '.' => [Dot];

(Start): '(' => [Par-Open];
(Start): ')' => [Par-Close];
(Start): '[' => [Sqr-Open];
(Start): ']' => [Sqr-Close];
(Start): '{' => [Curl-Open];
(Start): '}' => [Curl-Close];

(Start): '=' => [Assign]:  '=' => [Equal];
(Start): '>' => [Greater]: '=' => [Greater-Equal];
(Start): '<' => [Less]:    '=' => [Less-Equal];
(Start): '!' => [Not]:     '=' => [Not-Equal];
(Greater): '>' => [Shift-Right];
(Less):    '<' => [Shift-Left];

# Comments
(Div): '/' => (Comment-Single): !'\n' => (Comment-Single) => ^[Comment];
(Div): '*' => (Comment-Multiple): '*' => (Comment-Multiple-End): '/' => (Comment-End) => ^[Comment];
(Comment-Multiple): * => (Comment-Multiple);
(Comment-Multiple-End): * => (Comment-Multiple);

# Whitespace
(Start): ' \t\n' => (Whitespace): ' \t\n' => ^[Whitespace];

# Specific Keywords
[Identifier] = 'true', 'false' => [Bool];
[Identifier] = 'namespace' => [Namespace];

[Identifier] = 'in'      => [Declare-In];
[Identifier] = 'get'     => [Declare-Get];
[Identifier] = 'const'   => [Declare-Const];
[Identifier] = 'counter' => [Declare-Counter];
[Identifier] = 'latch'   => [Declare-Latch];
[Identifier] = 'toggle'  => [Declare-Toggle];

[Identifier] = 'bool'    => [Type-Bool];
[Identifier] = 'int'     => [Type-Int];
[Identifier] = 'double'  => [Type-Double];
[Identifier] = 'string'  => [Type-String];
[Identifier] = 'trigger' => [Type-Trigger];

# Reserved Identifiers (Keeping options open for future versions)
[Identifier] = 'byte', 'char', 'enum', 'float', 'int8', 'int16', 'int32', 'int64',
               'list', 'long', 'map', 'set', 'short', 'struct', 'type', 'uint',
               'uint8', 'uint16', 'uint32', 'uint64', 'ulong', 'ushort', 'var' => [Reserved-Types];

[Identifier] = 'internal', 'global', 'local',
               'private', 'protected', 'public', 'static' => [Reserved-Scoping];

[Identifier] = 'abstract', 'class', 'def', 'define', 'func', 'interface', 'operator',
               'override', 'typedef', 'void', 'virtual' => [Reserved-Definitions];

[Identifier] = 'as', 'break', 'catch', 'case', 'continue', 'default', 'else',
               'finally', 'go', 'if', 'import', 'intersect', 'is', 'out', 'return', 'select',
               'switch', 'then', 'try', 'typeof', 'union', 'using', 'when', 'yield' => [Reserved-Constructs];

[Identifier] = 'complex', 'do', 'dynamic', 'for', 'foreach', 'goto',
               'label', 'null', 'readonly', 'sealed', 'until', 'while' => [Reserved-Unsupported];

#==========================================================
# Grammar Rules

> <Code> := _
    | {Clean} <Statement> <Code>;

<Statement> := _
    | <Namespace>
    | <New-Typed-Input>
    | <New-Var-Input>
#    | <Assign-Existing>
#    | <Define-Typed-Rule>
#    | <Define-Var-Rule>
#    | <Pull-Trigger>
    ;

#----------------------------------------------------------

<Namespace> := [Namespace] <Create-Namespaced-Id> {Push-Namespace} [Curl-Open] <Code> [Curl-Close] {Pop-Namespace};
    | [Namespace] <Create-Namespaced-Id> [End];

#----------------------------------------------------------

<New-Typed-Input> := [Declare-In] <Any-Type> <New-Typed-Input-Part> <New-Typed-Input-Tail> [End];

<New-Typed-Input-Tail> := _
    | [Comma] <New-Typed-Input-Part> <New-Typed-Input-Tail>;

<New-Typed-Input-Part> := <Create-Namespaced-Id> {New-Type-Input-No-Assign}
    | <Create-Namespaced-Id> [Assign] <Conditional> {New-Type-Input-With-Assign};

#----------------------------------------------------------

<New-Var-Input> := [Declare-In] <New-Var-Input-Part> <New-Var-Input-Tail> [End];

<New-Var-Input-Tail> := _
    | [Comma] <New-Var-Input-Part> <New-Var-Input-Tail>;

<New-Var-Input-Part> := <Create-Namespaced-Id> [Assign] <Conditional> {New-Var-Input-With-Assign};

#----------------------------------------------------------

###<Assign-Existing> := <Id> <Assign-Existing-More> [Assign] <Conditional> {Assign-Existing};
###
###<Assign-Existing-More> := _
###    | [Assign] <Id> <Assign-Existing-More>;
###
###<Define-Typed-Rule> := {Start-Define} [Type] {Set-Type} <Id> [Define] <Conditional> {Type-Define};
###
###<Define-Var-Rule> := {Start-Define} <Id> [Define] <Conditional> {Var-Define};
###
###<Pull-Trigger> := [Trigger] <Id> {Pull-Trigger}
###    | <Conditional> [Trigger] <Id> {Conditional-Pull-Trigger};

#----------------------------------------------------------

<Create-Namespaced-Id> := [Identifier] {Create-Id-Start} <Create-Namespaced-Id-Tail>;

<Create-Namespaced-Id-Tail> := _
    | [Dot] [Identifier] {Member-Create} <Create-Namespaced-Id-Tail>;
    
#==========================================================

<Conditional> := <Logical-Or>
    | <Conditional> [Test] <Conditional> [Else] <Conditional> {Trinary};

<Logical-Or> := <Logical-Xor>
    | <Logical-Or> [Logical-Or] <Logical-Xor> {Logical-Or};
    
<Logical-Xor> := <Logical-And>
    | <Logical-Xor> [Logical-Xor] <Logical-And> {Logical-Xor};

<Logical-And> := <Equality>
    | <Logical-And> [Logical-And] <Equality> {Logical-And};

<Equality> := <Relational>
    | <Equality> [Equal]     <Relational> {Equal}
    | <Equality> [Not-Equal] <Relational> {Not-Equal};

<Relational> := <Bitwise-Or>
    | <Relational> [Greater]       <Bitwise-Or> {Greater}
    | <Relational> [Less]          <Bitwise-Or> {Less}
    | <Relational> [Greater-Equal] <Bitwise-Or> {Greater-Equal}
    | <Relational> [Less-Equal]    <Bitwise-Or> {Less-Equal};

<Bitwise-Or> := <Bitwise-Xor>
    | <Bitwise-Or> [Or] <Bitwise-Xor> {Or};
    
<Bitwise-Xor> := <Bitwise-And>
    | <Bitwise-Xor> [Xor] <Bitwise-And> {Xor};

<Bitwise-And> := <Bitwise-Shift>
    | <Bitwise-And> [And] <Bitwise-Shift> {And};

<Bitwise-Shift> := <Additive>
    | <Bitwise-Shift> [Shift-Right] <Additive> {Shift-Right}
    | <Bitwise-Shift> [Shift-Left]  <Additive> {Shift-Left};

<Additive> := <Multiplicative>
    | <Additive> [Pos] <Multiplicative> {Sum}
    | <Additive> [Neg] <Multiplicative> {Subtract};

<Multiplicative> := <Unary>
    | <Multiplicative> [Mul]       <Exponent> {Multiply}
    | <Multiplicative> [Div]       <Exponent> {Divide}
    | <Multiplicative> [Mod]       <Exponent> {Modulo}
    | <Multiplicative> [Remainder] <Exponent> {Remainder};

<Exponent> := <Unary>
    | <Exponent> [Power] <Unary> {Power};

<Unary> := <Expression>
    | [Neg]    <Expression> {Negate}
    | [Not]    <Expression> {Not}
    | [Pos]    <Expression>
    | [Invert] <Expression> {Invert}
    | [Par-Open] <Any-Type> [Par-Close] <Expression> {Cast};

<Expression> := <Value>
    | [Par-Open] <Conditional> [Par-Close]
    | <Expression> [Par-Open] {Start-Args} <Args> [Par-Close] {Call}
    | <Expression> [Dot] <Value> {Member-Access};

<Args> := _
    | <Conditional> {Add-Arg} <Args-Tail>;

<Args-Tail> := _
    | [Comma] <Conditional> {Add-Arg} <Args-Tail>;

<Value> := [Identifier] {Push-Id}
    | [Bool] {Push-Bool}
    | [Int] {Push-Int}
    | [Hex] {Push-Hex}
    | [Double] {Push-Double}
    | [String] {Push-String};

<Any-Type> := [Type-Bool] {Push-Type}
    | [Type-Int] {Push-Type}
    | [Type-Double] {Push-Type}
    | [Type-String] {Push-Type}
    | [Type-Trigger] {Push-Type};
