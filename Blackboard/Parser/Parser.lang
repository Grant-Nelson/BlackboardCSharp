# Blackboard Parser Language v1.0

> (Start);

# Integers
(Start): '0' => (Zero): '0'..'9' => (Int);
(Start): '1'..'9' => (Int): '0'..'9' => [Int];
(Zero) => [Int];

# Floats
(Start): '.' => (Decimal);
(Int): '.' => (Decimal): '0'..'9' => (Float-Dec): '0'..'9' => (Float-Dec) => [Float];
(Int): 'eE' => (Float-Exp-Start): '-' => (Float-Exp-Neg): '0'..'9' => (Float-Exp);
(Float-Dec): 'eE' => (Float-Exp-Start): '0'..'9' => (Float-Exp): '0'..'9' => (Float-Exp) => [Float];

# Hexadecimals
(Zero): 'x' => (Hex-Start): '0'..'9', 'a'..'f', 'A'..'F' => (Hex): '0'..'9', 'a'..'f', 'A'..'F' => [Hex];

# Identifiers
(Start): 'a'..'z', 'A'..'Z', '_$' => (Identifier): '0'..'9', 'a'..'z', 'A'..'Z', '_' => [Identifier];

# Symbols
(Start): '&' => [And]: '&' => [Logical-And];
(Start): '|' => [Or]: '|' => [Logical-Or];
(Start): '+' => [Pos];
(Start): '-' => [Neg]: '>' => [Trigger];
(Start): '/' => [Div];
(Start): '*' => [Mul]: '*' => [Power];
(Start): '%' => [Mod]: '%' => [Remainder];
(Start): '^' => [Xor]: '^' => [Logical-Xor];
(Start): '~' => [Invert];
(Start): '?' => [Test];
(Start): ':' => [Else]: '=' => [Define];
(Start): ';' => [End];
(Start): ',' => [Comma];
(Start): '.' => [Dot];

(Start): '(' => [Par-Open];
(Start): ')' => [Par-Close];
(Start): '[' => [Sqr-Open];
(Start): ']' => [Sqr-Close];
(Start): '{' => [Curl-Open];
(Start): '}' => [curl-Close];

(Start): '=' => [Assign]:  '=' => [Equal];
(Start): '>' => [Greater]: '=' => [Greater-Equal];
(Start): '<' => [Less]:    '=' => [Less-Equal];
(Start): '!' => [Not]:     '=' => [Not-Equal];
(Greater): '>' => [Shift-Right];
(Less):    '<' => [Shift-Left];

# Comments
(Div): '/' => (Comment-Single): !'\n' => (Comment-Single) => ^[Comment];
(Div): '*' => (Comment-Multiple): '*' => (Comment-Multiple-End): '/' => (Comment-End) => ^[Comment];
(Comment-Multiple): * => (Comment-Multiple);
(Comment-Multiple-End): * => (Comment-Multiple);

# Whitespace
(Start): ' \t\n' => (Whitespace): ' \t\n' => ^[Whitespace];

# Reserved Identifiers
[Identifier] = 'in' => [In];
[Identifier] = 'bool', 'int', 'float', 'trigger' => [Type];
[Identifier] = 'true', 'false' => [Bool];
[Identifier] = 'and', 'as', 'byte', 'catch', 'case', 'char', 'class', 'complex', 'def', 'default', 'do', 'dynamic',
               'else', 'enum', 'finally', 'for', 'foreach', 'func', 'get', 'global', 'if', 'interface', 'import', 'is',
               'list', 'local', 'map', 'namespace', 'not', 'null', 'on', 'operator', 'or', 'out', 'override', 'select',
               'set', 'static', 'string', 'switch', 'then', 'try', 'type', 'typedef', 'typeof', 'uint', 'until',
               'var', 'void', 'when', 'while', 'yield', 'xor' => [Reserved];

#==========================================================
# Grammar Rules

> <Code> := _
    | {Clean} <Statement> [End] <Code>;

<Statement> := _
    | <New-Typed-Input>
    | <New-Var-Input>
    | <Assign-Existing>
    | <Define-Typed-Rule>
    | <Define-Var-Rule>
    | <Pull-Trigger>;

<New-Typed-Input> := [In] [Type] {SetType} <New-Typed-Input-Part> <New-Typed-Input-Tail>;

<New-Typed-Input-Tail> := _
    | [Comma] <New-Typed-Input-Part> <New-Typed-Input-Tail>;

<New-Typed-Input-Part> := <Id> {NewTypeInputNoAssign}
    | <Id> [Assign] <Conditional> {NewTypeInputWithAssign};

<New-Var-Input> := [In] <New-Var-Input-Part> <New-Var-Input-Tail>;

<New-Var-Input-Tail> := _
    | [Comma] <New-Var-Input-Part> <New-Var-Input-Tail>;

<New-Var-Input-Part> := <Id> [Assign] <Conditional> {NewVarInputWithAssign};

<Assign-Existing> := <Id> <Assign-Existing-More> [Assign] <Conditional> {AssignExisting};

<Assign-Existing-More> := _
    | [Assign] <Id> <Assign-Existing-More>;

<Define-Typed-Rule> := {StartDefine} [Type] {SetType} <Id> [Define] <Conditional> {TypeDefine};

<Define-Var-Rule> := {StartDefine} <Id> [Define] <Conditional> {VarDefine};

<Pull-Trigger> := [Trigger] <Id> {PullTrigger}
    | <Conditional> [Trigger] <Id> {ConditionalPullTrigger};

#----------------------------------------------------------

<Conditional> := <Logical-Or>
    | <Conditional> [Test] <Conditional> [Else] <Conditional> {Trinary};

<Logical-Or> := <Logical-Xor>
    | <Logical-Or> [Logical-Or] <Logical-Xor> {Logical-Or};
    
<Logical-Xor> := <Logical-And>
    | <Logical-Xor> [Logical-Xor] <Logical-And> {Logical-Xor};

<Logical-And> := <Equality>
    | <Logical-And> [Logical-And] <Equality> {Logical-And};

<Equality> := <Relational>
    | <Equality> [Equal]     <Relational> {Equal}
    | <Equality> [Not-Equal] <Relational> {Not-Equal};

<Relational> := <Bitwise-Or>
    | <Relational> [Greater]       <Bitwise-Or> {Greater}
    | <Relational> [Less]          <Bitwise-Or> {Less}
    | <Relational> [Greater-Equal] <Bitwise-Or> {Greater-Equal}
    | <Relational> [Less-Equal]    <Bitwise-Or> {Less-Equal};

<Bitwise-Or> := <Bitwise-Xor>
    | <Bitwise-Or> [Or] <Bitwise-Xor> {Or};
    
<Bitwise-Xor> := <Bitwise-And>
    | <Bitwise-Xor> [Xor] <Bitwise-And> {Xor};

<Bitwise-And> := <Bitwise-Shift>
    | <Bitwise-And> [And] <Bitwise-Shift> {And};

<Bitwise-Shift> := <Additive>
    | <Bitwise-Shift> [Shift-Right] <Additive> {Shift-Right}
    | <Bitwise-Shift> [Shift-Left]  <Additive> {Shift-Left};

<Additive> := <Multiplicative>
    | <Additive> [Pos] <Multiplicative> {Sum}
    | <Additive> [Neg] <Multiplicative> {Subtract};

<Multiplicative> := <Unary>
    | <Multiplicative> [Mul]       <Exponent> {Multiply}
    | <Multiplicative> [Div]       <Exponent> {Divide}
    | <Multiplicative> [Mod]       <Exponent> {Modulo}
    | <Multiplicative> [Remainder] <Exponent> {Remainder};

<Exponent> := <Unary>
    | <Exponent> [Power] <Unary> {Power};

<Unary> := <Expression>
    | [Neg]    <Expression> {Negate}
    | [Not]    <Expression> {Not}
    | [Pos]    <Expression>
    | [Invert] <Expression> {Invert};

<Expression> := <Value>
    | [Par-Open] <Conditional> [Par-Close]
    | <Id> {StartCall} [Par-Open] <Args> [Par-Close] {EndCall};

<Args> := _
    | <Conditional> <Args-Tail>;

<Args-Tail> := _
    | [Comma] <Conditional> <Args-Tail>;

<Value> := <Id> {PushId}
    | [Bool] {PushBool}
    | [Int] {PushInt}
    | [Hex] {PushHex}
    | [Float] {PushFloat};

<Id> := [Identifier] {StartId} <Id-Tail>;

<Id-Tail> := _ 
    | [Dot] [Identifier] {AddId} <Id-Tail>;
