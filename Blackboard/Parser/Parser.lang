# Blackboard Parser Language v1.0

> (Start);

# Integers
(Start): '0' => (Zero): '0'..'9' => (Int);
(Start): '1'..'9' => (Int): '0'..'9' => [Int];
(Zero) => [Int];

# Floats
(Start): '.' => (Decimal);
(Int): '.' => (Decimal): '0'..'9' => (Float-Dec): '0'..'9' => (Float-Dec) => [Float];
(Int): 'eE' => (Float-Exp-Start): '-' => (Float-Exp-Neg): '0'..'9' => (Float-Exp);
(Float-Dec): 'eE' => (Float-Exp-Start): '0'..'9' => (Float-Exp): '0'..'9' => (Float-Exp) => [Float];

# Hexadecimals
(Zero): 'x' => (Hex-Start): '0'..'9', 'a'..'f', 'A'..'F' => (Hex): '0'..'9', 'a'..'f', 'A'..'F' => [Hex];

# Identifiers
(Start): 'a'..'z', 'A'..'Z', '_$' => (Identifier): '0'..'9', 'a'..'z', 'A'..'Z', '_' => [Identifier];

# Symbols
(Start): '&' => [And]: '&' => [Logical-And];
(Start): '|' => [Or]: '|' => [Logical-Or];
(Start): '+' => [Pos];
(Start): '-' => [Neg]: '>' => [Trigger];
(Start): '/' => [Div];
(Start): '*' => [Mul]: '*' => [Power];
(Start): '%' => [Mod]: '%' => [Remainder];
(Start): '^' => [Xor]: '^' => [Logical-Xor];
(Start): '~' => [Invert];
(Start): '?' => [Test];
(Start): ':' => [Else]: '=' => [Define];
(Start): ';' => [End];
(Start): ',' => [Comma];
(Start): '.' => [Dot];

(Start): '(' => [Par-Open];
(Start): ')' => [Par-Close];
(Start): '[' => [Sqr-Open];
(Start): ']' => [Sqr-Close];
(Start): '{' => [Curl-Open];
(Start): '}' => [curl-Close];

(Start): '=' => [Assign]:  '=' => [Equal];
(Start): '>' => [Greater]: '=' => [Greater-Equal];
(Start): '<' => [Less]:    '=' => [Less-Equal];
(Start): '!' => [Not]:     '=' => [Not-Equal];
(Greater): '>' => [Shift-Right];
(Less):    '<' => [Shift-Left];

# Comments
(Div): '/' => (Comment-Single): !'\n' => (Comment-Single) => ^[Comment];
(Div): '*' => (Comment-Multiple): '*' => (Comment-Multiple-End): '/' => (Comment-End) => ^[Comment];
(Comment-Multiple): * => (Comment-Multiple);
(Comment-Multiple-End): * => (Comment-Multiple);

# Whitespace
(Start): ' \t\n' => (Whitespace): ' \t\n' => ^[Whitespace];

# Reserved Identifiers
[Identifier] = 'in' => [In];
[Identifier] = 'const' => [Const];
[Identifier] = 'bool', 'int', 'float', 'trigger' => [Type];
[Identifier] = 'true', 'false' => [Bool];
[Identifier] = 'and', 'as', 'byte', 'catch', 'case', 'char', 'class', 'complex', 'def', 'default', 'do', 'dynamic',
               'else', 'enum', 'finally', 'for', 'foreach', 'func', 'get', 'global', 'if', 'interface', 'import', 'is',
               'list', 'local', 'map', 'namespace', 'not', 'null', 'on', 'operator', 'or', 'out', 'override', 'select',
               'set', 'static', 'string', 'switch', 'then', 'try', 'type', 'typedef', 'typeof', 'uint', 'until',
               'var', 'void', 'when', 'while', 'yield', 'xor' => [Reserved];

#==========================================================
# Grammar Rules

> <Code> := _
    | {Clean} <Statement> [End] <Code>;

<Statement> := _
    | [In] [Type] [Identifier] {NewInput}
    | {StartAssign} [In] [Type] [Identifier] [Assign] <Conditional> {EndAssignWithType}
    | {StartAssign} [In]        [Identifier] [Assign] <Conditional> {EndAssignWithoutType}
    | {StartAssign}             [Identifier] [Assign] <Conditional> {EndAssignExisting}
    | {StartDefine} [Type] [Identifier] [Define] <Conditional> {EndDefineWithType}
    | {StartDefine}        [Identifier] [Define] <Conditional> {EndDefineWithoutType}
    | {StartConst}  [Const] [Type] [Identifier] [Assign] <Conditional> {EndConstWithType}
    | {StartConst}  [Const]        [Identifier] [Assign] <Conditional> {EndConstWithoutType}
    | [Trigger] [Identifier] {PullTrigger};

<Conditional> := <Logical-Or>
    | <Conditional> [Test] <Conditional> [Else] <Conditional> {Trinary};

<Logical-Or> := <Logical-Xor>
    | <Logical-Or> [Logical-Or] <Logical-Xor> {Logical-Or};
    
<Logical-Xor> := <Logical-And>
    | <Logical-Xor> [Logical-Xor] <Logical-And> {Logical-Xor};

<Logical-And> := <Equality>
    | <Logical-And> [Logical-And] <Equality> {Logical-And};

<Equality> := <Relational>
    | <Equality> [Equal]     <Relational> {Equal}
    | <Equality> [Not-Equal] <Relational> {Not-Equal};

<Relational> := <Bitwise-Or>
    | <Relational> [Greater]       <Bitwise-Or> {Greater}
    | <Relational> [Less]          <Bitwise-Or> {Less}
    | <Relational> [Greater-Equal] <Bitwise-Or> {Greater-Equal}
    | <Relational> [Less-Equal]    <Bitwise-Or> {Less-Equal};

<Bitwise-Or> := <Bitwise-Xor>
    | <Bitwise-Or> [Or] <Bitwise-Xor> {Or};
    
<Bitwise-Xor> := <Bitwise-And>
    | <Bitwise-Xor> [Xor] <Bitwise-And> {Xor};

<Bitwise-And> := <Bitwise-Shift>
    | <Bitwise-And> [And] <Bitwise-Shift> {And};

<Bitwise-Shift> := <Additive>
    | <Bitwise-Shift> [Shift-Right] <Additive> {Shift-Right}
    | <Bitwise-Shift> [Shift-Left]  <Additive> {Shift-Left};

<Additive> := <Multiplicative>
    | <Additive> [Pos] <Multiplicative> {Sum}
    | <Additive> [Neg] <Multiplicative> {Subtract};

<Multiplicative> := <Unary>
    | <Multiplicative> [Mul]       <Exponent> {Multiply}
    | <Multiplicative> [Div]       <Exponent> {Divide}
    | <Multiplicative> [Mod]       <Exponent> {Modulo}
    | <Multiplicative> [Remainder] <Exponent> {Remainder};

<Exponent> := <Unary>
    | <Exponent> [Power] <Unary> {Power};

<Unary> := <Expression>
    | [Neg]    <Expression> {Negate}
    | [Not]    <Expression> {Not}
    | [Pos]    <Expression>
    | [Invert] <Expression> {Invert};

<Expression> := <Value>
    | <Expression> [Dot] [Identifier] {Receiver}
    | [Par-Open] <Conditional> [Par-Close]
    | [Identifier] {StartCall} [Par-Open] <Args> [Par-Close] {EndCall};

<Args> := _
    | <Conditional> <Args-Tail>;

<Args-Tail> := _
    | [Comma] <Conditional> <Args-Tail>;

<Value> := [Identifier] {PushId}
    | [Bool] {PushBool}
    | [Int] {PushInt}
    | [Hex] {PushHex}
    | [Float] {PushFloat};
